---
title: JavaScript 解决方案
date: 2025-09-25 16:39:58
permalink: /fe/javaScript-solution
categories:
  - 编程
  - 前端
  - JavaScript
tags:
  - JavaScript
  - 解决方案
---

## 跨标签页传输

在浏览器中的不同标签页之间进行数据传递和通信的过程。同源情况下可以优先使用 **Broadcast Channel**，非同源情况下推荐使用 **Web Socket**。

| 方案                  | 优点                          | 缺点                                            |
| --------------------- | :---------------------------- | :---------------------------------------------- |
| postMessage           | 1. 兼容性好<br />2. 实现简单  | 需要获取对应标签页的引用                        |
| Storage Event         | 1. 兼容性好<br />2. 实现简单  | 1. 需同源<br />2. 存储大小限制                  |
| Shared Worker         | 后台线程运行                  | 1. 需同源<br />2. 需考虑兼容性                  |
| Message Channel       | 相较于 postMeesage 简化了使用 | 1. 需提前传递 channel port<br />2. 需考虑兼容性 |
| **Broadcast Channel** | 实现简单，使用方便            | 1. 需同源<br />2. 需考虑兼容性                  |
| **Web Socket**        | 使用方便                      | 1. 需要服务器端支持<br />2. 网络通信消耗        |
| **...**               |                               |                                                 |

### 1. postMessage

**window.postMessage()** 方法可以安全地实现跨源通信。

```js
// page one
const popup = window.open(...popup details...);
popup.postMessage('message', targetOrigin, [transfer])

// page two
window.addEventListener('message', (e) => {
  // 校验信息来源
  if (e.origin !== targetOrigin) {
    return
  }
  // => event.data
})
```

### 2. Storage Event

作为 Web Storage API 的接口，**Storage** 提供了访问特定域名下的会话存储或本地存储的功能，例如，可以添加、修改或删除存储的数据项。

```js
// page one
localStorage.setItem('message', 'data');

// page two
window.addEventListener('storage', (e) => {
  if (e.key === 'message') {
  	// => event.data
  }
})
```

### 3. Shared Worker

**SharedWorker** 接口代表一种特定类型的 worker，可以从几个浏览上下文中访问，例如几个窗口、iframe 或其他 worker。

```js
// page one
const worker = new SharedWorker('worker.js')
worker.port.postMessage('message')

// page two
const worker = new SharedWorker('worker.js')
worker.port.addEventListener('message', (e) => {
  // => e.data
})

// worker.js
self.addEventListener('connect', (e) => {
  const port = e.ports[0]
  port.addEventListener('message', (event) => {
    port.postMessage(event.data)
  })
})
```

### 4. Message Channel

**Channel Messaging API** 的 MessageChannel 接口允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。

```js
// page one
const channel = new MessageChannel()
const popup = window.open(...popup details...);
popup.postMessage(message, targetOrigin, [channel.prot2])
channel.port1.addEventListener('message', (e) => {
	// => e.data
})
channel.port1.start() // 使用 addEventListener 注册事件时需显式调用

// page two
window.addEventListener("message", (e) => {
  // 校验信息来源
  if (e.origin !== targetOrigin) {
    return
  }
  const messagePort = e.ports?.[0]
  messagePort.postMessage('message')
})
```

### 5. Broadcast Channel

**BroadcastChannel** 接口表示**给定源**的任何浏览上下文都可以订阅的命名频道。它允许**同源**的不同浏览器窗口、标签页、frame 或者 iframe 下的同文档之间相互通信。消息通过 message 事件进行广播，该事件在侦听该频道的所有 BroadcastChannel 对象上触发，发送消息的对象除外。

```js
// page one
const channel = new BroadcastChannel('channelName')
channel.postMessage('message');

// page two
const channel = new BroadcastChannel('channelName')
channel.addEventListener('message', (e) => {
  // => e.data
})
```

### 6. Web Socket

**WebSocket** 对象提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。

```js
// page one
const socket = new WebSocket('ws://localhost:8080')
socket.addEventListener('open', (e) => {
  socket.send('message');
})

// page two
const socket = new WebSocket('ws://localhost:8080')
socket.addEventListener('message', (e) => {
  // => e.data
})
```

## 大屏适配

为了使页面根据设备视口动态调整显示尺寸，技术点为自适应匹配。选用方案时如客户不介意屏幕留边则可以使用 scale 方案，如果不能留边则使用 vw/vh 方案。

| 方案      | 优点                                                         | 缺点                                                         |
| --------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| scale     | 代码量少，适配简单，无须其他操作                             | 1. 因为是根据 UI 稿等比缩放，当大屏跟 UI 稿的比例不一样时，会出现周边留白情况<br/>2. 当缩放比例过大时，字体会有一点点模糊<br />3. 当缩放比例过大时候，事件热区会偏移 |
| rem       | 可以动态计算图表的宽高，字体等，灵活性较高                   | 1. 因为是根据 UI 稿等比缩放，当大屏跟 UI 稿的比例不一样时，会出现周边留白情况<br/>2. 图表需要单个做字体、间距、位移的适配 |
| **vw/vh** | 1. 可以动态计算图表的宽高，字体等，灵活性较高<br/>2. 当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况 | 图表需要单个做字体、间距、位移的适配                         |
| **...**   |                                                              |                                                              |

### 1. scale

- 当**视口宽高比 < 设计稿宽高比**，缩放的比例是视口宽度 / 设计稿宽度，**适配宽度**。

- 当**视口宽高比 > 设计稿宽高比**，缩放的比例是视口高度 / 设计稿高度，**适配高度**。

```js
const scale =
  document.documentElement.clientWidth / document.documentElement.clientHeight < designDraftWidth / designDraftHeight
    ? document.documentElement.clientWidth / designDraftWidth
    : document.documentElement.clientHeight / designDraftHeight
// 适配短边
document.querySelector('#layout').style.transform = `scale(${scale})`
```

```css
#layout {
  transform-origin: left top;
}
```

### 2. rem

动态获取视口宽度并设置 html font-size 为视口宽度的十分之一（方便计算），将 px 单位转换为 rem 单位即可适配（可使用插件）。

- 当**视口宽高比 < 设计稿宽高比**，以宽高比 * 视口宽度 / 10 进行 rem 适配。
- 当**视口宽高比 > 设计稿宽高比**，以 1 * 视口宽度 / 10 进行 rem 适配。

```js
const html = document.documentElement
const screenRatioByDesign = 1920 / 1080
const screenRatio = html.clientWidth / html.clientHeight
const fontSize = ((screenRatioByDesign < screenRatio ? screenRatioByDesign / screenRatio : 1) * html.clientWidth) / 10
html.style.fontSize = fontSize.toFixed(3) + 'px'
```

### 3. vw/vh

按照设计稿的尺寸，将 px 按比例计算转为 vw 和 vh。

```scss
@use 'sass:math';

// 设计稿的宽度
$design-width: 1920;

// 设计稿的高度
$design-height: 1080;

// px to vw
@function vw($px) {
  @return math.div($px, $design-width) * 100vw;
}

// px to vh
@function vh($px) {
  @return math.div($px, $design-height) * 100vh;
}
```
