---
title: Git 常用命令
date: 2025-09-25 15:11:30
permalink: /tools/git-command
categories:
  - 工具
  - 版本管理工具
tags:
  - Git
  - 常用命令
  - 一览
---

## 命令一览表

| 命令分类     |                       |                           |                       |                       |                         |
| ------------ | --------------------- | ------------------------- | --------------------- | --------------------- | ----------------------- |
| `初始化命令` | [init](#git-init)     | [clone](#git-clone)       |                       |                       |                         |
| `配置命令`   | [help](#git-help)     | [config](#git-config)     |                       |                       |                         |
| `基础命令`   | [status](#git-status) | [ad](#git-ad)             | [mv](#git-mv)         | [rm](#git-rm)         | [restore](#git-restore) |
|              | [reset](#git-reset)   | [stash](#git-stash)       | [commit](#git-commit) | [tag](#git-tag)       | [show](#git-show)       |
|              | [log](#git-log)       | [reflog](#git-reflog)     | [diff](#git-diff)     |                       |                         |
| `分支命令`   | [branch](#git-branch) | [checkout](#git-checkout) | [merge](#git-merge)   | [rebase](#git-rebase) | [fetch](#git-fetch)     |
|              | [pull](#git-pull)     | [push](#git-push)         |                       |                       |                         |

## 初始化命令

### git init

创建一个空的 Git 存储库或重新初始化现有的存储库。

#### SYNOPSIS

```sh
git init [-q | --quiet] [--bare] [--template=<template-directory>]
         [--separate-git-dir <git-dir>] [--object-format=<format>]
         [-b <branch-name> | --initial-branch=<branch-name>]
         [--shared[=<permissions>]] [<directory>]
```

#### USE

```sh
git init
```

### git clone

将存储库克隆到新目录中。

#### SYNOPSIS

```sh
git clone [--template=<template-directory>]
          [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]
          [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]
          [--dissociate] [--separate-git-dir <git-dir>]
          [--depth <depth>] [--[no-]single-branch] [--no-tags]
          [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]
          [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--[no-]reject-shallow]
          [--filter=<filter> [--also-filter-submodules]] [--] <repository>
          [<directory>]
```

## 配置命令

### git help

显示有关 Git 的帮助信息。

#### SYNOPSIS

```sh
git help [-a|--all] [--[no-]verbose] [--[no-]external-commands] [--[no-]aliases]
git help [[-i|--info] [-m|--man] [-w|--web]] [<command>|<doc>]
git help [-g|--guides]
git help [-c|--config]
git help [--user-interfaces]
git help [--developer-interfaces]
```

#### USE

```sh
# 查看帮助
git help <command>
git help -a # 列出所有命令
```

### git config

获取和设置存储库或全局选项。

#### SYNOPSIS

```sh
git config [<file-option>] [--type=<type>] [--fixed-value] [--show-origin] [--show-scope] [-z|--null] <name> [<value> [<value-pattern>]]
git config [<file-option>] [--type=<type>] --add <name> <value>
git config [<file-option>] [--type=<type>] [--fixed-value] --replace-all <name> <value> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get <name> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get-all <name> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] [--name-only] --get-regexp <name-regex> [<value-pattern>]
git config [<file-option>] [--type=<type>] [-z|--null] --get-urlmatch <name> <URL>
git config [<file-option>] [--fixed-value] --unset <name> [<value-pattern>]
git config [<file-option>] [--fixed-value] --unset-all <name> [<value-pattern>]
git config [<file-option>] --rename-section <old-name> <new-name>
git config [<file-option>] --remove-section <name>
git config [<file-option>] [--show-origin] [--show-scope] [-z|--null] [--name-only] -l | --list
git config [<file-option>] --get-color <name> [<default>]
git config [<file-option>] --get-colorbool <name> [<stdout-is-tty>]
git config [<file-option>] -e | --edit
```

#### USE

```sh
# 配置级别
--system # 系统级，位于 /etc/gitconfig
--global # 用户级，位于 ~/.gitconfig
--local # 仓库级，位于 [repo]/.git/config，为默认级别且优先级最高

# 查看
git config --global -l

# 添加/修改
git config --global user.name "True"
git config --global user.email "643345861@qq.com"
git config --global -e # 编辑模式

# 删除
git config --global --unset user.name
git config --global --unset user.email
```
## 基础命令

### git status

显示工作树状态。

#### SYNOPSIS

```sh
git status [<options>…​] [--] [<pathspec>…​]
```

#### USE

```sh
# 以长格式给出输出。这是默认行为
git status

# 以短格式给出输出
git status -s
git status -sb # 附加分支信息

# 除了已更改的文件名称之外，还显示暂存要提交的文本更改
git status -v
git status -vv # 如果 -v 指定两次，则还显示工作树中尚未暂存的更改
```

### git add

将文件内容添加到索引。

#### SYNOPSIS

```sh
git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]
        [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--sparse]
        [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]
        [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]
        [--] [<pathspec>…​]
```

#### USE

```sh
# 将以 .js 结尾的文件添加至索引
git add *.js
git add *.js -v # 详细信息

# 更新索引
git add -A # 不仅在工作树具有与 <pathspec> 匹配的文件的情况下更新索引，而且在索引已具有条目的情况下更新索引
git add -u # 在已有匹配 <pathspec> 的条目的位置更新索引（不包括新文件）
git add . # 受当前目录限制的 -A
git add * # 受当前目录限制的 -A 且不包括 . 开头的文件
```

### git mv

移动或重命名文件、目录或符号链接。

#### SYNOPSIS

```sh
git mv <options>… <args>…
```

#### USE

```sh
# 重命名
git mv README README.md
git mv README README.md -f # 强制
git mv README README.md -k # 跳过可能导致错误情况的移动或重命名操作
```

### git rm

从工作树和索引中删除文件。

#### SYNOPSIS

```sh
git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]
       [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]
       [--] [<pathspec>…]
```

#### USE

```sh
# 删除
git rm [<pathspec>…]
git rm -f [<pathspec>…] # 强制删除，用于已暂存的文件/目录
git rm --cached [<pathspec>…] # 从索引中删除
```

### git restore

恢复工作树文件。

#### SYNOPSIS

```sh
git restore [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>…​
git restore [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul]
git restore (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>…​]
```

#### USE

```sh
git restore --staged <pathspec>…​ # 指定恢复索引
git restore <pathspec>…​ # 不指定则恢复索引与工作树
```

### git reset

将当前 HEAD 重置为指定状态。

#### SYNOPSIS

```sh
git reset [-q] [<tree-ish>] [--] <pathspec>…​
git reset [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>…​]
git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]
DEPRECATED: git reset [-q] [--stdin [-z]] [<tree-ish>]
```

#### USE

```sh
git reset [<mode>] [<commit>] [<pathspec>…​]
--soft # 根本不触及索引文件或工作树（但将头重置为<commit>，就像所有模式一样）
--mixed # 重置索引但不重置工作树（即保留更改的文件但不标记为提交）并报告尚未更新的内容。这是默认操作
--hard # 重置索引和工作树。此后对工作树中跟踪文件的任何更改都<commit>将被丢弃。任何未跟踪的文件或写入任何跟踪文件的目录都会被简单地删除

git reset --hard <branch> # 重置并指定指向分支

# Version
^, ^^, ^^^, ... # 上 ... 个版本
~, ~~, ~~~, ... # 上 ... 个版本
~0, ~1, ~2 .... # 上 ... 个版本
```

### git stash

将更改存储在脏工作目录中。

#### SYNOPSIS

```sh
git stash list [<log-options>]
git stash show [-u|--include-untracked|--only-untracked] [<diff-options>] [<stash>]
git stash drop [-q|--quiet] [<stash>]
git stash ( pop | apply ) [--index] [-q|--quiet] [<stash>]
git stash branch <branchname> [<stash>]
git stash [push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-q|--quiet]
          [-u|--include-untracked] [-a|--all] [-m|--message <message>]
          [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>…​]]
git stash clear
git stash create [<message>]
git stash store [-m|--message <message>] [-q|--quiet] <commit>
```

#### USE

```sh
git stash # 保存本地修改并恢复工作目录以匹配HEAD提交
git stash list # 列出当前拥有的存储条目，每个存储条目都列出了其名称（例如stash@{0}，是最新条目、stash@{1}是之前的条目等）
git stash show # 将存储条目中记录的更改显示为存储内容与首次创建存储条目时的提交之间的差异

git stash push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [-m|--message <message>] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>…​] # 将本地修改保存到新的存储条目并将其回滚到 HEAD（在工作树和索引中）
git stash pop [--index] [-q|--quiet] [<stash>] # 从存储列表中删除单个存储状态并将其应用到当前工作树状态之上
git stash apply [--index] [-q|--quiet] [<stash>] # 类似于 pop，但不要从存储列表中删除状态

git stash branch <branchname> [<stash>] # 创建并签出一个新分支，<branchname>该分支从<stash>最初创建的提交开始命名，将记录的更改应用<stash>到新的工作树和索引

git stash clear # 删除所有隐藏条目
git stash drop [-q|--quiet] [<stash>] # 从存储条目列表中删除单个存储条目
```

### git commit

记录对存储库的更改。

#### SYNOPSIS

```sh
git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]
           [--dry-run] [(-c | -C | --squash) <commit> | --fixup [(amend|reword):]<commit>)]
           [-F <file> | -m <msg>] [--reset-author] [--allow-empty]
           [--allow-empty-message] [--no-verify] [-e] [--author=<author>]
           [--date=<date>] [--cleanup=<mode>] [--[no-]status]
           [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]
           [(--trailer <token>[(=|:)<value>])…] [-S[<keyid>]]
           [--] [<pathspec>…]
```

#### USE

```sh
git commit -m "message" # 使用给定的 <msg> 作为提交消息
git commit -am "message" # 告诉命令自动暂存已修改和删除的文件，但您未告知 Git 的新文件不受影响
```

### git tag

创建、列出、删除或验证使用 GPG 签名的标签对象。

#### SYNOPSIS

```sh
git tag [-a | -s | -u <keyid>] [-f] [-m <msg> | -F <file>] [-e]
        <tagname> [<commit> | <object>]
git tag -d <tagname>…
git tag [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]
        [--points-at <object>] [--column[=<options>] | --no-column]
        [--create-reflog] [--sort=<key>] [--format=<format>]
        [--merged <commit>] [--no-merged <commit>] [<pattern>…]
git tag -v [--format=<format>] <tagname>…
```

#### USE

```sh
# 展示所有 tag
git tag

# 打标签
git tag v1.0.1 <commit>
git tag -a v1.0.1 -m "Release Version 1.0.1" <commit> # 打附注标签

# 删除标签
git tag -d v1.0.1
```

### git show

显示各种类型的对象。

#### SYNOPSIS

```sh
git show [<options>] [<object>…]
```

#### USE

```sh
# 为最新提交时下列操作显示一致
git show
git show -s # 简短显示
git show HEAD
git show master
git show v1.0.1
```

### git log

显示提交日志。

#### SYNOPSIS

```sh
git log [<options>] [<revision-range>] [[--] <path>…]
```

#### USE

```sh
git log # 展示所有记录
git log -p # 按补丁格式显示每个更新的差异
git log --stat # 显示每次提交修改文件的统计信息
git log --oneline # 这是一起使用的“--pretty=oneline --abbrev-commit”的简写
git log --graph # 在输出的左侧绘制提交历史的基于文本的图形表示
```

### git reflog

管理引用日志信息。

#### SYNOPSIS

```sh
git reflog <subcommand> <options>

git reflog [show] [<log-options>] [<ref>]
git reflog expire [--expire=<time>] [--expire-unreachable=<time>]
        [--rewrite] [--updateref] [--stale-fix]
        [--dry-run | -n] [--verbose] [--all [--single-worktree] | <refs>…​]
git reflog delete [--rewrite] [--updateref]
        [--dry-run | -n] [--verbose] <ref>@{<specifier>}…​
git reflog exists <ref>
```

#### USE

```sh
git reflog show # 接受任何选项 git log
```

### git diff

显示提交、提交和工作树等之间的更改。

#### SYNOPSIS

```sh
git diff [<options>] [<commit>] [--] [<path>…​]
git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>…​]
git diff [<options>] [--merge-base] <commit> [<commit>…​] <commit> [--] [<path>…​]
git diff [<options>] <commit>…​<commit> [--] [<path>…​]
git diff [<options>] <blob> <blob>
git diff [<options>] --no-index [--] <path> <path>
```

#### USE

```sh
git diff <commit> # 比较 工作树 与 版本库的差异
git diff --cached <commit> # 比较 暂存区 与 版本库的差异
git diff <commit1> <commit2> # 比较两次提交的差异

git diff --stat # 简洁的展示差异
```
## 分支命令

### git branch

列出、创建或删除分支。

#### SYNOPSIS

```sh
git branch [--color[=<when>] | --no-color] [--show-current]
        [-v [--abbrev=<n> | --no-abbrev]]
        [--column[=<options>] | --no-column] [--sort=<key>]
        [--merged [<commit>]] [--no-merged [<commit>]]
        [--contains [<commit>]] [--no-contains [<commit>]]
        [--points-at <object>] [--format=<format>]
        [(-r | --remotes) | (-a | --all)]
        [--list] [<pattern>…​]
git branch [--track[=(direct|inherit)] | --no-track] [-f]
        [--recurse-submodules] <branchname> [<start-point>]
git branch (--set-upstream-to=<upstream> | -u <upstream>) [<branchname>]
git branch --unset-upstream [<branchname>]
git branch (-m | -M) [<oldbranch>] <newbranch>
git branch (-c | -C) [<oldbranch>] <newbranch>
git branch (-d | -D) [-r] <branchname>…​
git branch --edit-description [<branchname>]
```

#### USE

```sh
git branch -l # 列出本地分支
git branch -r # 列出远程分支
git branch -a # 列出远程跟踪分支和本地分支

git branch -f # 将 <branchname> 重置为 <startpoint>，即使 <branchname> 已存在。如果没有-f，git 分支将拒绝更改现有分支。与-d(或--delete) 结合使用，允许删除分支，无论其合并状态如何，或者是否指向有效的提交。与 -m(或--move) 结合使用，即使新分支名称已存在，也允许重命名分支，这同样适用于-c(或--copy)

git branch -d # 删除一个分支
git branch -D # --delete --force

git branch -c # 复制
git branch -C # --copy --force

git branch -m # 移动/重命名分支及其配置和引用日志
git branch -M # --move --force
```

### git checkout

切换分支或恢复工作树文件。

#### SYNOPSIS

```sh
git checkout [-q] [-f] [-m] [<branch>]
git checkout [-q] [-f] [-m] --detach [<branch>]
git checkout [-q] [-f] [-m] [--detach] <commit>
git checkout [-q] [-f] [-m] [[-b|-B|--orphan] <new-branch>] [<start-point>]
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>…​
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]
git checkout (-p|--patch) [<tree-ish>] [--] [<pathspec>…​]
```

#### USE

```sh
git checkout <branch> # 切换分支
git checkout -b <branch> # 创建并切换分支

git checkout . <commit> # 指定所有文件检出到指定提交，默认当前，则效果为根据最新的暂存区提交恢复工作树
git checkout -- <pathspec>…​ <commit> # 指定文件检出到指定提交

git checkout -f # 切换分支时，即使索引或工作树与 HEAD 不同，并且即使途中存在未跟踪的文件，也要继续进行。这用于丢弃本地更改以及任何阻碍的未跟踪文件或目录
```

### git merge

将两个或多个开发历史连接在一起。

#### SYNOPSIS

```sh
git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]
          [--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]]
          [--[no-]allow-unrelated-histories]
          [--[no-]rerere-autoupdate] [-m <msg>] [-F <file>]
          [--into-name <branch>] [<commit>…​]
git merge (--continue | --abort | --quit)
```

#### USE

```sh
git merge <branch> # 合并指定分支到当前分支

git merge --ff # 指定当合并历史记录已经是当前历史记录的后代时如何处理合并
	# 使用--ff时，如果可能，将合并解析为快进（仅更新分支指针以匹配合并的分支；不创建合并提交）。如果不可能（当合并的历史记录不是当前历史记录的后代时），请创建合并提交
	# 使用--no-ff，在所有情况下都创建合并提交，即使可以将合并解析为快进
	# 使用--ff-only，尽可能将合并解决为快进。当不可能时，拒绝合并并以非零状态退出
```

### git rebase

在另一个基本提示之上重新应用提交。

#### SYNOPSIS

```sh
git rebase [-i | --interactive] [<options>] [--exec <cmd>]
    	     [--onto <newbase> | --keep-base] [<upstream> [<branch>]]
git rebase [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>]
     	     --root [<branch>]
git rebase (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)
```

#### USE

```sh
git rebese [master] # 将当前分支的基底改为 master 的最新提交
git rebase master <branch> # 快捷操作，将 dev 分支的基底改为 master

git rebase --onto master <branch1> <branch2> # 从 branch1 和 branch2 的共同分支后的 branch2 分支变基为 master
```

### git fetch

从另一个存储库下载对象和引用。

#### SYNOPSIS

```sh
git fetch [<options>] [<repository> [<refspec>…​]]
git fetch [<options>] <group>
git fetch --multiple [<options>] [(<repository> | <group>)…​]
git fetch --all [<options>]
```

#### USE

```sh
git fetch origin master # 从一个或多个其他存储库获取分支和/或标签（统称为“引用”），以及完成其历史记录所需的对象
```

### git pull

从另一个存储库或本地分支获取并与其集成。

#### SYNOPSIS

```sh
git pull [<options>] [<repository> [<refspec>…​]]
```

#### USE

```sh
git pull origon matser:<localBranch> # 拉取 origon 主机的 master 分支到本地的 locaBranch 分支
git pull origon matser # 省略本地分支名则默认分支名相同

git pull --rebase # 拉取合并时执行变基操作
```

### git push

更新远程引用以及关联的对象。

#### SYNOPSIS

```sh
git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
         [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]
         [-u | --set-upstream] [-o <string> | --push-option=<string>]
         [--[no-]signed|--signed=(true|false|if-asked)]
         [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]
         [--no-verify] [<repository> [<refspec>…​]]
```

#### USE

```sh
git push -u # 对于每个最新或成功推送的分支，添加上游（跟踪）引用，由无参数 git-pull 和其他命令使用

git push -u origin master # 推送当前分支到 origin 的 master 分支
```

